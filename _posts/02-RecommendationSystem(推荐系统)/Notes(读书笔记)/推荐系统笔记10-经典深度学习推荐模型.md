---
title: 深度学习推荐系统-笔记10：经典的深度学习推荐模型
tags:
  - 推荐模型
comments: true
categories:
  - 深度学习推荐系统
mathjax: true
abbrlink: e066db0
date: 2021-01-05 21:44:40
top: 8
---

特征组合和特征交叉问题非常常见，特征的种类非常多，特征交叉的复杂程度也要大得多。解决这类问题的关键，就是**模型对于特征组合和特征交叉的学习能力**，因为它决定了模型对于未知特征组合样本的预测能力，而这对于复杂的推荐问题来说，是决定其推荐效果的关键点之一。

那特征交叉与深度学习模型的拟合能力有什么关系呢？以MLP为例：

① MLP具有拟合任意函数的能力，是建立在MLP有任意多层网络，以及任意多个神经元的前提下的。

② 在训练资源有限，调参时间有限的现实情况下，MLP对于特征交叉的处理其实还比较低效。因为MLP是通过 concatenate层把所有特征连接在一起成为一个特征向量的，这里面没有特征交叉，两两特征之间没有发生任何关系。

③ 在我们有先验知识的情况下，人为地加入一些负责特征交叉的模型结构，其实对提升模型效果会非常有帮助。这就是深度学习模型要加强特征交叉能力的原因。

接下来介绍下经典深度学习推荐模型的发展历程。

### 1. AutoRec - 基础结构

#### （1）介绍

2015年，澳大利亚国立大学提出的AutoRec，将自编码器（AutoEncoder）的思想与协同过滤结合，提出了一种单隐层神经网络推荐模型，结构简单明了，清晰易懂。

利用协同过滤（CF）中的共现矩阵，完成物品向量或者用户向量的自编码，再利用自编码的结果到用户对物品的预估评分，进行推荐排序。

自编码器的本质是起到降维作用，把稀疏的高维转成稠密的低维。

#### （2）模型结构

![AutoRec结构图](https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/v2-ad0a881a7fc9683baf4f60e436ea7518_1440w.jpg)

结构非常简单，就是一个单隐层的自编码器，也就是输入等于输出的结构。

① 输入：共现矩阵中物品$i$的向量$\vec{r^{(i)}}$，$m$表示物品向量维数。

② 隐层：蓝色圆圈表示$k(k << m)$维隐层神经元，向量$\boldsymbol{V}$表示输入到隐层的权重参数矩阵。

③ 输出：与输入相等，其中向量$\boldsymbol{W}$表示隐层到输出的权重参数矩阵。

用数学形式表示如下：
$$
h(r; \theta) = f(\boldsymbol{W} \cdot g(\boldsymbol{V} \vec{r} + \mu) + b)
$$
其中$f(\cdot)，g(\cdot)$分别是输入层神经元和隐层神经元的激活函数。

#### （3）目标函数

目标函数形式如下，后边一项是L2正则化项，目的是为了防止过拟合：
$$
\underset{\theta}{min} \sum^{n}_{i=1} || \vec{r^{(i)}} - h(\vec{r^{(i)}}; \theta) ||^{2}_{\omicron} + \frac{\lambda}{2} \cdot (||\boldsymbol{W}||^{2}_{F} + ||\boldsymbol{V}||^{2}_{F})
$$
其中$||\cdot||^{2}_{F}$表示是L2范数，训练方法用梯度反向传播即可。

#### （4）推荐过程

① 当输入物品$i$的向量$\vec{r^{(i)}}$时，模型的输出向量$h(\vec{r^{(i)}}; \theta)$就是所有用户对物品$i$的评分。<!-- 没懂 -->

② 第$u$维就是用户$u$对物品$i$的评分。

③ 遍历输入物品向量，就可以得到用户$u$对所有物品的评分列表。

④ 把评分列表排序得到推荐列表。

#### （5）特点

① 优点：使用了单隐层神经元，具有一定的泛化性。

② 缺点：因为结构比较简单，所以表达能力不足。

③ 意义：拉开了使用深度学习的思想解决推荐问题的序幕，为复杂的深度学习网络构建提供了思路。

### 2. Deep Crossing - 经典结构

#### （1）介绍

2016年，微软提出了[Deep Crossing](https://www.kdd.org/kdd2016/papers/files/adf0975-shanA.pdf)，是一次深度学习架构在推荐系统中的完整应用。相比AutoRec模型过于简单的网络结构，Deep Crossing模型完整的解决了从特征工程、稀疏向量稠密化、深层神经网络目标优化等一系列问题。微软的应用场景是搜索引擎Bing中的搜索广告推荐场景。目标是在返回的搜索结果中带有相关广告，尽可能增加广告的点击率，准确地预测其点击率，并以此作为广告排序的指标之一。

#### （2）模型结构

端到端训练需要解决的问题如下：

① 解决离散类特征编码后过于稀疏问题

② 解决特征自动交叉组合问题

③ 解决在输出层中完成优化目标的问题。

![Deep Crossing结构图](https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/image-20210312141846107.png)

模型主要由4层组成：

① Embedding层：作用是将稀疏的类别型特征转成稠密向量，结构上主要以全连接层（FC）为主。就Embedding技术本身而言，已经衍生除了Word2vec、Graph Embedding等多种不同的Embedding方法，请参考《[深度学习推荐系统-笔记05：Embedding技术](https://notlate.net/posts/ba149af9.html)》。数值型特征不需要编码，直接进入Stacking层。

② Stacking层：作用比较简单，把不同的Embedding特征和数值型特征拼接在一起，形成完整的特征向量。结构上通常是concat。

③ Multiple Residual Units层：作用是对特征向量各个维度进行充分交叉组合，是模型能够挖掘到更多的非线性特征和组合特征的信息，提高模型的表达能力。结构上主要是引入了著名的残差结构（详细可以阅读《[详解残差网络-知乎](https://zhuanlan.zhihu.com/p/42706477)》）的多层感知机。

④ Scoring层：输出层，作用是拟合优化目标，对于CTR预估这种二分类问题，结构往往使用LR结构；对于类似图像分类等多分类问题，结构往往采用Softmax结构。

#### （3）损失函数

$$
logloss=-\frac{1}{N}\sum_{i=1}^{N}(y_ilog(p_i)+(1-y_i)log(1-p_i))
$$

这个是损失函数是针对二分类的任务，实际任务中可以灵活替换。

#### （4）特点

①  基于Embedding+MLP架构设计

② 特征交叉层复杂度较高

### 3. NeuralCF - CF与深度学习结合

#### （1）介绍

CF（协同过滤）发展出了矩阵分解技术，就是把共现矩阵分解为用户向量矩阵和物品向量矩阵。在预测时，计算用户隐向量和物品隐向量的内积，作为用户对物品的评分预测。2017年，新加坡国立大学研究员提出了基于深度学习的协同过滤模型NeuralCF（[Neural Collaborative Filtering](http://184pc128.csie.ntnu.edu.tw/presentation/19-10-18/Neural Collaborative Filtering.pdf)）。

#### （2）模型结构

<img src="https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/7063d223da013845534d3c84b7ab9409-20210116205913169.jpg" alt="NeuralCF模型结构图" style="zoom:33%;" />

左图是矩阵分解技术的网络化表示，右图是NeuralCF结构，很显然区别就是用神经网络代替了矩阵分解中的内积操作（那么原来的内积操作是什么作用？上边已经介绍过了，就是用于计算用户对所有物品的评分列表，然后排序生成推荐列表）。

替换掉内积的好处是什么呢？① 让用户向量和物品向量做更充分的交叉，得到更多的有用价值的特征组合信息。② 引入更多的非线性特征，让模型的表达能力更强。

按照这种思路，用户和物品向量的互操作可以被替换成任意的互操作，这就是“广义矩阵分解”模型。

![NeuralCF混合模型](https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/webp)

进一步分析，还可以把多种互操作得到的特征向量拼接起来，再送到输出层进行目标拟合。如上图，用户和物品向量分别经过GMF层和MLP层的互操作之后拼接起来，再送入输出层NeuralCF结构进行目标拟合。这样让模型具有了更强的特征组合和非线性能力。

#### （3）目标函数

输出层使用softmax激活函数输出多分类的概率分布，在分类问题中，softmax往往和交叉熵损失函数一起使用，因为交叉熵刻画了预测分类与真实结果之间的相似度。先定义似然函数（含义是表示物品$i$和用户$u$的相似性）如下：
$$
p( \mathcal{Y}, \mathcal{Y^-} \mid \boldsymbol{P},\boldsymbol{Q},\Theta_f)=\prod_{(u,i)\in \mathcal{Y}} \hat{y_{ui}} \prod_{(u,i)\in \mathcal{Y^-}}(1- \hat{y_{uj}})
$$
其中$\mathcal{Y}, \mathcal{Y^-}$分别表示观测样本集和负样本（未观测到的样本）集合； $\boldsymbol{P},\boldsymbol{Q}$分别表示用户和物品隐向量矩阵； $\Theta_f$表示交互操作函数的模型参数 ； $\hat{y_{ui}}$表示预测输出，$y_{ui}$是标签值。

因此目标函数就是对上式相似性（概率值）进行等价变换，最小化其负对数，即最小化负对数似然函数，形式如下：
$$
L = -\sum_{(u,i)\in \mathcal{Y}}log \: \hat{y_{ui}}-\sum_{(u,j)\in \mathcal{Y^-}}log\:(1 - \hat{y_{uj}})=-\sum_{(u,i)\in \mathcal{Y}\,\cup \mathcal{Y^-}} y_{ui}\,log\, \hat{y_{ui}}+(1-y_{ui})\, log(1-\hat{y_{ui}})
$$


#### （4）特点

① NeuralCF实际提出了一种模型框架，基于用户和物品向量这个Embedding层，利用不同的互操作进行特征的交叉组合。

② 实践中并不是模型结构越复杂、特征越多越好。因为过于复杂之后容易出现过拟合和难收敛的问题。

③ 局限性：NeuralCF基于CF的思想，因此也没有引入更多其他类型的特征，比如用户和物品的属性信息等。

#### （5）泛化（双塔模型）

NeuralCF 的模型结构之中，蕴含了一个非常有价值的思想，就是我们可以把模型分成用户侧模型和物品侧模型两部分，然后用互操作层把这两部分联合起来，产生最后的预测得分。

这里的用户侧模型结构和物品侧模型结构，可以是简单的 Embedding 层，也可以是复杂的神经网络结构，最后的互操作层可以是简单的点积操作，也可以是比较复杂的 MLP 结构。

但只要是这种用户侧模型 + 物品侧模型 + 互操作层的模型结构，我们把它统称为“双塔模型”结构。

<img src="https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/66606828b2c80a5f4ea28d60762e82cf.jpg" alt="双塔模型结构" style="zoom:33%;" />

2019年，YouTube发表了论文《[Sampling-Bias-Corrected Neural Modeling for Large Corpus Item Recommendations](https://storage.googleapis.com/pub-tools-public-publication-data/pdf/6c8a86c981a62b0126a11896b7f6ae0dae4c3566.pdf)》，展示了其在构建用于召回层的双塔模型时，分别在用户侧和物品侧输入了多种不同的特征，结构图如下：

<img src="https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/e2603a22ec91a9f00be4b73feyy1f987.jpg" style="zoom:33%;" alt="YouTube召回双塔模型结构"/>

① 用户侧特征：包括了用户正在观看的视频 ID、频道 ID（图中的 seed features）、该视频的观看数、被喜欢的次数，以及用户历史观看过的视频 ID 等等

② 物品侧特征：包括了候选视频的 ID、频道 ID、被观看次数、被喜欢次数等等。

③ 输出：经过了多层 ReLU 神经网络的学习之后，双塔模型最终通过 softmax 输出层连接两部分，输出最终预测分数。

④ 优点：易上线、易服务。物品塔和用户塔最顶端的那层神经元，那层神经元的输出其实就是一个全新的物品 Embedding 和用户 Embedding。不用把整个模型都部署上线，只需要预存物品塔和用户塔的输出，以及在线上实现互操作层即可。

#### （6）总结

<img src="https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/image-20210117112017943.png" style="zoom:50%;" alt="NeuralCF架构总结"/>

① 能否在用户塔和物品塔中加入context信息？**不建议**。把context特征放进user塔或者item塔，那么离线生成user embedding或者item embedding的数量就要翻好多倍。

② 把context信息单独成塔？**有点得不偿失**，因为线上的context特征，比如时间，地点变化会非常快。所以理想的方式就是做实时inference。

### 4. PNN

#### （1）介绍

NeuralCF模型的局限性就是只能使用用户和物品向量，如果加入更多组特征向量呢？如何设计特征交互方法？2016年，上海交通大学的研究人员提出的PNN（[Product-based Neural Networks](https://ieeexplore.ieee.org/abstract/document/7837964)）模型，给出了几种设计特征交互方式的思路。

#### （2）模型结构

![PNN网络结构图](https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/image-20210312195035963.png)

相比Deep Crossing模型，PNN模型在在整体结构上没有区别，唯一的不同是PNN模型用乘积层（Product Layer）替代了Deep Crossing的Stacking层。就是Deep Crossing的用最简单的concat拼接Embedding特征和数值型特征，而PNN的思路则是使用Product操作进行两两交互，更有针对性的获取特征之间的交叉信息。

另外，PNN模型的输入不仅包括用户和物品信息，还可以有更多不同形式、不同类别的特征，通过Embedding层统一编码成长度一致的稠密特征向量。

#### （3）损失函数

同样是二分类的逻辑回归函数。

#### （4）特征交叉方式

如PNN结构图中Product层分为两部分：

① z部分是直接把Embedding结果线性拼接起来；

② p部分是对各特征向量进行两两的内积操作或者外积操作，因为是两两操作，所以p部分总共有$\frac{N(N-1)}{2}$个圆圈（神经元）。

##### 假如p部分是内积操作（称为IPNN模型）

每个圆圈（神经元）是一个标量，和z部分特征向量直接拼接起来输入下一层即可。

##### 假如p部分是外积操作（称为OPNN模型）

每个圆圈（神经元）是一个方阵，因此每个神经元需要搭配一个可学习的参数方阵$W$，两个方阵对应元素相乘之后，再把整个方阵累加成一个标量，剩下的就和内积操作一样了。

但是这样的话，问题的复杂度提升巨大，于是论文介绍了一种降维方法，把所有Embedding向量叠加，然后叠加后的特征向量通过外积互操作得到矩阵$\boldsymbol{p}$。然后再和L1层的$D_1$个权重方阵对应元素相乘再累加成标量，就得到了一个$D_1$维的输出向量。

**但是，并不建议上述降维方法，因为把不同特征向量对应维度累加，容易丢失或模糊很多有价值的信息，比如“年龄”和“地域”两个特征向量不在同一个向量空间中，显然不具备任何可比性，因为不应该直接操作。**

#### （5）特点

① 强调了特征之间的交叉方式是多样化的，有效的交叉方式会更有利于捕获特征的交叉信息。

② 局限性：外积操作为了简化操作，对特征进行了无差别的交叉、累加，忽略了原始特征中包含的高价值信息。

### 5. Wide&Deep - 广泛应用的结构（记忆能力和泛化能力）

#### （1）介绍

2016年，谷歌提出了[Wide&Deep模型](https://doi.org/10.1145/2988450.2988454)，由单层的Wide部分和多层的Deep部分组成的混合模型。其影响力一直延续至今，并且衍生出了大量的同结构的混合模型。

#### （2）模型结构

<img src="https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/fb17112c951ebb2a515f12dace262de0.jpg" alt="Wide&Deep结构图" style="zoom:50%;" />

① Wide部分位于左侧，结构简单，就是把输入层直接连接到输出层，中间没有做任何处理。作用是：让模型具有较强的“记忆能力”（Memorization）。

② Deep部分位于右侧，结构稍复杂，它就是 Embedding+MLP 的模型结构，作用是：让模型具有“泛化能力”（Generalization）。

正是这样的结构特点，使模型兼具逻辑回归和深度神经网络的优点：能够快速处理并记忆大量历史行为特征，同时具有强大的表示能力。

#### （3）记忆能力

① 概念：模型直接学习历史数据中物品或者特征的“共现频率”，并且把它们直接作为推荐依据的能力。

② 举例：在电影推荐中可以发现一系列的规则，比如，看了 A 电影的用户经常喜欢看电影 B，这种“因为 A 所以 B”式的规则，非常直接也非常有价值。

③ 特点：1）数量非常多，一个“记性不好”的推荐模型很难把它们都记住；2）没办法推而广之，因为这类规则非常具体，没办法或者说也没必要跟其他特征做进一步的组合。

④ 作用：让模型记住大量的直接且重要的规则，这正是单层的线性模型所擅长的。

#### （4）泛化能力

① 概念：模型对于新鲜样本、以及从未出现过的特征组合的预测能力。

② 举例1：假设我们知道 25 岁的男性用户喜欢看电影 A，35 岁的女性用户也喜欢看电影 A。问：“35 岁的男性喜不喜欢看电影 A”，那么：
* 只有记忆能力的模型回答：不知道，没有学过这个知识。
* 具有泛化能力的模型回答：从第1条可以学习到男性喜欢电影A，第2条可以学习到35岁喜欢电影A，那综合就是35岁男性喜欢电影A。

③ 举例2：矩阵分解算法，就是为了解决协同过滤“泛化能力”不强而诞生的。协同过滤只会“死板”地使用用户的原始行为特征，而矩阵分解因为生成了用户和物品的隐向量，所以就可以计算任意两个用户和物品之间的相似度了。

#### （5）应用场景

<img src="https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/4b2f89d82768ba851e3f7392b17df2be.jpg" alt="Google Play Wide&Deep模型结构图" style="zoom:33%;" />

① 右侧Wide部分：这部分很简单，只利用了两个特征的交叉，这两个特征是“已安装应用”和“当前曝光应用”。这样一来，Wide 部分想学到的知识就非常直观啦，就是希望记忆好“如果 A 所以 B”这样的简单规则。在 Google Play 的场景下，就是希望记住“如果用户已经安装了应用 A，是否会安装 B”这样的规则。

② 左侧Deep部分：是一个非常典型的 Embedding+MLP 结构。其中的输入特征很多，有用户年龄、属性特征、设备类型，还有已安装应用的 Embedding 等等，把这些特征一股脑地放进多层神经网络里面去学习之后，它们互相之间会发生多重的交叉组合，这最终会让模型具备很强的泛化能力。

#### （6）特点

Wide&Deep成功的关键在于：

① 抓住了业务问题的本质特点，融合了传统模型记忆能力和深度学习模型泛化能力的优势。

② 模型结构不复杂，易于工程实现、训练和线上服务，这加速了在业界的推广应用。

#### （7）问答经典

**① 如果把数值型特征放到wide部分，是否需要做normalization？**

做不做normalization还是看你自己的实践。作者一般推荐在实际工作中做normalization或者bucketize。会有助于模型收敛。

**② deep的输出是128，wide是10000，两个不在一个量纲，感觉直接这么concate，会不会削弱deep的效果，模型退化成LR？**

作者认为不会，因为wide部分一般来说都是非常稀疏的特征，虽然总的维度很大，但是在实际inference的过程中，wide部分往往只有几个维度是有值的，而deep部分一般都是稠密的特征向量，所以理论上两个部分对结果的影响不存在太大的bias

### 6. FM与深度学习结合

#### （1）介绍

2017年，由哈尔滨工业大学和华为公司联合提出的DeepFM，是将FM结构与Wide&Deep模型进行了整合。用FM替换了原来的Wide部分，加强了浅层网络部分特征组合的能力。

同年，新加坡国立大学研究人员提出了NFM模型，就是把FM结构和深度神经网络结合起来的一种尝试。

#### （2）DeepFM模型结构

<img src="https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/d0df6ed3958byyd9529efceebba64419-20210117114605406.png" alt="DeepFM结构图" style="zoom:50%;" />

DeepFM 利用了 Wide&Deep 组合模型的思想，用 FM 替换了 Wide&Deep 左边的 Wide 部分，加强了浅层网络部分特征组合的能力，而右边的部分跟 Wide&Deep 的 Deep 部分一样，主要利用多层神经网络进行所有特征的深层处理，最后的输出层是把 FM 部分的输出和 Deep 部分的输出综合起来，产生最后的预估结果。这就是 DeepFM 的结构。

#### （3）NFM模型结构

① 特征交叉新方法：元素积操作

<img src="https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/a2c0f6751f64f50e3c628bf86cd9b00c.jpg" alt="NFM结构图" style="zoom:50%;" />

Bi-Interaction Pooling Layer 翻译成中文就是“两两特征交叉池化层”。具体操作为：

<img src="https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/image-20210117115238461.png" style="zoom:50%;" />

其中 ⊙ 运算代表两个向量的元素积（Element-wise Product）操作，即两个长度相同的向量对应维相乘得到元素积向量。在进行两两特征 Embedding 向量的元素积操作后，再求取所有交叉特征向量之和，我们就得到了池化层的输出向量。接着，我们再把该向量输入上层的多层全连接神经网络，就能得出最后的预测得分。

② 特点：1）NFM 并没有使用内积操作来进行特征 Embedding 向量的交叉，而是使用元素积的操作。2）在得到交叉特征向量之后，也没有使用 concatenate 操作把它们连接起来，而是采用了求和的池化操作，把它们叠加起来。

#### （4）问答经典

**① 数值型特征是否可以用于特征交叉？**

* 按照DeepFM原论文，数值型特征是不参与特征交叉的，因为特征交叉的操作是在两个embedding向量间进行的。
* 如果可以把通过分桶操作把连续型特征处理成离散型特征，然后再加Embedding层，就可以让数值型特征也参与特征交叉。这是一个可行的方案。

**② FM与DeepFM交叉权重区别？**

* 原FM中内积作为权重，然后还要乘以特征本身的值。但在DeepFM中，所有的参与交叉的特征都先转换成了embedding，而且由于是one-hot，所以特征的值就是1，参不参与交叉都无所谓。所以直接使用embedding的内积作为交叉后的值就可以了

**③ FM与MF的区别：**
* 结构上来说，因子分解机会引入除了user id和item id的其他特征，而且FM是有一阶部分的，不只是做特征交叉。
* MF就是一个只利用user id和item Id的双塔模型。
* MF有多种的求解方式，比如奇异值分解（SVD）、特征值分解（ED）、梯度下降法。

### 7. 注意力机制与深度学习结合

#### （1）介绍

**“注意力机制”来源于人类天生的“选择性注意”的习惯**。最典型的例子是用户在浏览网页时，会有选择性地注意页面的特定区域，而忽视其他区域。

近年来，注意力机制广泛应用在深度学习的各个领域，无论是自然语言处理、语音识别还是计算机视觉领域，注意力模型都取得了巨大的成功。从2017年开始，推荐领域也开始尝试把注意力机制引入推荐模型。

2017年，阿里巴巴提出了深度兴趣网络（[Deep Interest Network，DIN](https://dl.acm.org/doi/abs/10.1145/3219819.3219823)）。

2019年，提出了其演进版本深度兴趣进化网络（[Deep Interest Evolution Network，DIEN](https://ojs.aaai.org/index.php/AAAI/article/view/4545)）。

这两个网络都是CTR预估网络。

#### （2）注意力机制在DIN上的应用

**DIN的基础模型结构**：是一个典型的 Embedding MLP 的结构。它的输入特征有用户属性特征（User Proflie Features）、用户行为特征（User Behaviors）、候选广告特征（Candidate Ad）和场景特征（Context Features）。

<img src="https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/c1dbcc00dd17166ec53ca9e46b04006e.jpg" alt="DIN基础模型结构图" style="zoom:50%;" />

① 用户行为特征是由一系列用户购买过的商品组成的，也就是图上的 Goods 1 到 Goods N，而每个商品又包含了三个子特征，也就是图中的三个彩色点，其中红色代表商品 ID，蓝色是商铺 ID，粉色是商品类别 ID。同时，候选广告特征也包含了这三个 ID 型的子特征，因为这里的候选广告也是一个阿里平台上的商品。

② 把三个 ID 转换成了对应的 Embedding，然后把这些 Embedding 连接起来组成了当前商品的 Embedding。

③ 用户的行为序列是一组商品的序列，这个序列可长可短，但是神经网络的输入向量的维度必须是固定的。SUM Pooling 层的结构直接把这些商品的 Embedding 叠加起来，然后再把叠加后的 Embedding 跟其他所有特征的连接结果输入 MLP。

④ **问题来了**：SUM Pooling 的 Embedding 叠加操作其实是把所有历史行为一视同仁，没有任何重点地加起来，这其实并不符合我们购物的习惯。

⑤ **DIN模型结构图**

<img src="https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/edd028f815ef3577553ffe045f042330.jpg" alt="DIN模型结构图" style="zoom:50%;" />

与 Base Model 相比，DIN 为每个用户的历史购买商品加上了一个激活单元（Activation Unit），这个激活单元生成了一个权重，这个权重就是用户对这个历史商品的注意力得分，权重的大小对应用户注意力的高低。

⑥ 激活单元：它的输入是当前这个历史行为商品的 Embedding，以及候选广告商品的 Embedding。我们把这两个输入 Embedding，与它们的外积结果连接起来形成一个向量，再输入给激活单元的 MLP 层，最终会生成一个注意力权重，这就是激活单元的结构。简单来说，激活单元就相当于一个小的深度学习模型，它利用两个商品的 Embedding，生成了代表它们关联程度的注意力权重。

#### （3）兴趣进化序列模型

① 无论是电商购买行为，还是视频网站的观看行为，或是新闻应用的阅读行为，特定用户的历史行为都是一个随时间排序的序列。既然是和时间相关的序列，就一定存在前后行为的依赖关系，这样的序列信息对于推荐过程是非常有价值的

② 深度兴趣进化网络 DIEN（Deep Interest Evolution Network）模型正好弥补了 DIN 模型没有对行为序列进行建模的缺陷，它围绕兴趣进化这个点进一步对 DIN 模型做了改进。

③ DIEN架构：整体上仍然是一个 Embedding MLP 的模型结构。与 DIN 不同的是，DIEN 用“兴趣进化网络”，也就是图中的彩色部分，替换掉了原来带有激活单元的用户历史行为部分。这部分虽然复杂，但它的输出只是一个 h'(T) 的 Embedding 向量，它代表了用户当前的兴趣向量。有了这个兴趣向量之后，再把它与其他特征连接在一起，DIEN 就能通过 MLP 作出最后的预测了

<img src="https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/56c93e11aa3503852c37cd18db740da0.jpg" alt="DIEN模型结构图" style="zoom:33%;" />

④ **兴趣进化网络**
* 最下面一层是**行为序列层（Behavior Layer，灰绿色部分）**。它的主要作用和一个普通的 Embedding 层是一样的，负责把原始的 ID 类行为序列转换成 Embedding 行为序列。
* 再上一层是**兴趣抽取层（Interest Extractor Layer，浅黄色部分）**。它的主要作用是利用 GRU 组成的序列模型，来模拟用户兴趣迁移过程，抽取出每个商品节点对应的用户兴趣。
* 最上面一层是**兴趣进化层（Interest Evolving Layer，浅红色部分）**。它的主要作用是利用 AUGRU(GRU with Attention Update Gate) 组成的序列模型，在兴趣抽取层基础上加入注意力机制，模拟与当前目标广告（Target Ad）相关的兴趣进化过程，兴趣进化层的最后一个状态的输出就是用户当前的兴趣向量 h'(T)。

⑤ 序列模型结构

兴趣抽取层和兴趣进化层都用到了序列模型的结构（如下图是RNN模型的典型结构）。

<img src="https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/f69c0f565b5fa31023b727192d3b1d37.jpg" style="zoom:50%;" alt="序列模型结构图"/>

根据**序列模型神经元结构**的不同，最经典的有[RNN](https://arxiv.org/pdf/1406.1078.pdf)、[LSTM](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.676.4320&rep=rep1&type=pdf)、[GRU](https://arxiv.org/pdf/1412.3555.pdf)这 3 种，各神经元结构图如下：

<img src="https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/bed695e253a49e6f08a6627782ec9202.jpg" style="zoom:33%;" />

⑥ 在 DIEN 模型中，神经元的输入就是商品 ID 或者前一层序列模型的 Embedding 向量，而输出就是商品的 Embedding 或者兴趣 Embedding，除此之外，每个神经元还会与后续神经元进行连接，用于预测下一个状态，放到 DIEN 里就是为了预测用户的下一个兴趣。这就是序列模型的结构和作用。

#### （4）总结

<img src="https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/image-20210117145053119.png" style="zoom:50%;" />

#### （5）问答经典

**① 有没有更实用的注意力权重计算方式？**

* 可以借鉴FM及DeepFM中特征交叉的计算方式，对两个向量直接计算内积
* 先通过Embedding层转换成维度相等的Embedding再求内积
* 可以像双塔结构一样，设计一个历史行为物品塔和广告物品塔，在塔的最后通过求内积或者拼接后用全连接层输出权重

**② DIN激活单元用到了外积，有什么意图？**

* 本质上**内积**和**外积**都是做特征交叉，计算相似性的方式，一般来说，外积因为输出是一个向量，所以表达能力更强一些
  

**③ DIN模型在工业界的排序阶段使用的多吗？**

* DIN比DIEN的使用场景要求低很多，很多团队在用，或者说很多团队在用DIN的思路来构建自己的模型。作者经验：attention机制是非常有价值的
  

**④ GRU这种提取序列信息的方式肯定会被Transformer取代？**

* 已经有不少的paper介绍Transformer替代GRU，最近提的比较多的是bert for rec。
  

**⑤ 广告的内容和商城的内容（包含用户行为）是不一样的，这时候还可以用DIN的注意力机制了吗？**

* 作者认为可以的，因为广告内容和商城内容从经验上来说也会有一定的相关性。以DeepFM的思路来说，其实可以做任意两个特征之间的交叉。对于注意力机制，当然也可以学任意两个特征间的注意力。但到底作用有多大，能不能提高效果，就看自己的实践了。

**⑥ 推荐模型的NN隐层数量都比较少（相对cv），业界常用的MLP隐层数量和神经元数量，有没有一个大致的取值范围？**

* 隐层数量大致在1到5之间吧，确实在推荐问题上再提高隐层数量效果上意义不大，inference延迟还大，得不偿失。
* 相比CV动辄上百的隐层数量，推荐模型是比较“浅”的了。CV的输入特征都是稠密的数值特征，相比推荐来说，特征维度就比较大，所以需要更深的网络来做特征提取。
* 同时，推荐模型大多数特征都是结构化的数据，因此只能用全连接来对特征进行提取，而过深的全连接层会带来大量的参数，使得模型训练效率低等问题；对于CV来说，其主要考虑的是三维数据的空间特征提取，CNN中卷积核是权重共享的，这就解决全连接层参数爆炸的问题。

**⑦ transformer中有position encoding，而在推荐的领域中，点击的序列中同样有时间间隔的因素，例如取用户最近若干次点击，可能每次间隔时间不等。这个间隔时间应该是有信息可以揭示用户兴趣的变迁速率等信息的吧？但是如何将其引入到推荐序列中呢？是类似于transformer中 position learned encoding这样么？**

* 这是一个很好的idea。但说实话我还没有见到非常成功的案例说能够很好的利用event interval然后取得很大的收益。也许是这个信号本身不够强，带来的收益有限。

**⑧ 查阅了关于外积的资料，向量外积一般只定义在3维空间，对于高于3维空间的向量如何计算其外积呢？我在DIN作者的开源项目中发现作者自己没有使用外积运算，而是使用了元素相减和元素相乘，不知道老师在DIN或相关实践中是否会使用外积操作来进行向量的融合呢？**

* 我也不喜欢用外积操作，我比较喜欢inner product和element wise操作。外积我始终没法得到更好的效果。DIN的paper中加入了外积操作，也许身体是诚实的，还是用了传统的交互操作。没必要纠结这些，自己实践中哪个好用用哪个。

### 8. 强化学习与深度学习结合

#### （1）背景

强化学习也被称为增强学习，它在模型实时更新、用户行为快速反馈等方向上拥有巨大的优势。自从 2018 年开始，它就被大量应用在了推荐系统中，短短几年时间内，[微软](http://www.personal.psu.edu/~gjz5038/paper/www2018_reinforceRec/www2018_reinforceRec.pdf)、[美团](https://tech.meituan.com/2018/11/15/reinforcement-learning-in-mt-recommend-system.html)、[阿里](https://arxiv.org/abs/1803.00710)等多家一线公司都已经有了强化学习的成功应用案例。

#### （2）基本概念

基本原理：就是一个**智能体通过与环境进行交互，不断学习强化自己的智力，来指导自己的下一步行动，以取得最大化的预期利益。**

为了把强化学习技术落地，只清楚它的基本原理显然是不够的，我们需要清晰地定义出强化学习中的每个关键变量，形成一套通用的技术框架。对于一个通用的强化学习框架来说，有这么**六个元素**是必须要有的：

* **智能体（Agent）**：强化学习的主体也就是作出决定的“大脑”；
* **环境（Environment）**：智能体所在的环境，智能体交互的对象；
* **行动（Action）**：由智能体做出的行动；
* **奖励（Reward）**：智能体作出行动后，该行动带来的奖励；
* **状态（State）**：智能体自身当前所处的状态；
* **目标（Objective）**：指智能体希望达成的目标。

通用过程描述：一个**智能体**身处在不断变化的**环境**之中，为了达成某个**目标**，它需要不断作出**行动**，行动会带来**好**或者不好的奖励，智能体收集起这些**奖励**反馈进行自我学习，改变自己所处的**状态**，再进行下一步的行动，然后智能体会持续这个“**行动 - 奖励 - 更新状态**”的循环，不断优化自身，直到达成设定的目标。

#### （3）强化学习推荐系统框架

① **深度强化学习网络DRN（Deep Reinforcement Learning Network）**，是微软在 2018 年提出的，它被应用在了新闻推荐的场景上。深度强化学习推荐系统框架图如下：

<img src="https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/2ff55be8dea34e992bcb09e1f3c39a27.jpg" style="zoom:50%;" alt="深度强化学习推荐系统框架图"/>

② DRN学习过程：

* 第一步是初始化推荐系统，主要初始化的是推荐模型，我们可以利用离线训练好的模型作为初始化模型，其他的还包括我们之前讲过的特征存储、推荐服务器等等。
* 接下来，推荐系统作为智能体会根据当前已收集的用户行为数据，也就是当前的状态，对新闻进行排序这样的行动，并在新闻网站或者 App 这些环境中推送给用户。
* 用户收到新闻推荐列表之后，可能会产生点击或者忽略推荐结果的反馈。这些反馈都会作为正向或者负向奖励再反馈给推荐系统。
* 推荐系统收到奖励之后，会根据它改变、更新当前的状态，并进行模型训练来更新模型。接着，就是推荐系统不断重复“排序 - 推送 - 反馈”的步骤，直到达成提高新闻的整体点击率或者用户留存等目的为止。

③ 强化学习六要素与推荐系统的关系总结：

<img src="https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/eac0fea51d5033a35332cd81f653202b.jpeg" style="zoom:33%;" alt="强化学习六要素与推荐系统的关系总结图" />

④ 强化学习推荐系统的特点：始终在强调**持续学习**和**实时训练**。它不断利用新学到的知识更新自己，做出最及时的调整，这也正是将强化学习应用于推荐系统的收益所在。

#### （4）深度强化学习推荐模型 DRN

① 智能体是强化学习框架的核心，作为推荐系统这一智能体来说，**推荐模型**就是推荐系统的“大脑”。在 DRN 框架中，扮演“大脑”角色的是 **Deep Q-Network (深度 Q 网络，DQN)**。其中，Q 是 Quality 的简称，指通过对行动进行质量评估，得到行动的效用得分，来进行行动决策。

② DQN模型结构：如下图所示，它就是一个典型的**双塔结构**。用户塔的输入特征是**用户特征和环境特征**，物品塔的输入向量是**所有的用户、环境、用户 - 新闻交叉特征和新闻特征**。

<img src="https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/75d38d425b1a72350ce85e8b676d928a.jpg" alt="DQN模型结构图" style="zoom:50%;" />

③ 在强化学习的框架下，**用户塔特征向量**因为代表了用户当前所处的状态，所以也可被视为**状态向量**。**物品塔特征向量**则代表了系统下一步要选择的新闻，这个选择新闻的过程就是智能体的“行动”，所以物品塔特征向量也被称为**行动向量**。

④ 双塔模型通过对**状态向量**和**行动向量**分别进行 **MLP 处理**，再用互操作层生成了最终的**行动质量得分 Q(s,a)**，智能体正是通过这一得分的高低，来选择到底做出哪些行动，也就是推荐哪些新闻给用户的。

⑤ **DRN学习过程**

<img src="https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/96509410e50e019e5077f6a2a909292a.jpg" alt="DRN学习过程图" style="zoom:33%;" />

* **离线部分初始化**：DRN 根据历史数据训练好 DQN 模型，作为智能体的初始化模型。
* **在线t1->t2时间段**：DRN 利用初始化模型进行一段时间的推送服务，积累反馈数据
* **t2时间点**：DRN 利用 t1 到 t2 阶段积累的用户点击数据，进行模型微更新（Minor update），**基于新的在线训练方法，Dueling Bandit Gradient Descent algorithm（竞争梯度下降算法）**
* **t4时间点**：DRN 利用 t1 到 t4 阶段的用户点击数据及用户活跃度数据，进行模型的主更新（Major update），**可以理解为：利用历史数据的重新训练，用训练好的模型来替代现有模型。**
* **重复t1->t4阶段的操作**

⑥ **在线学习方法：竞争梯度下降算法**

<img src="https://cdn.jsdelivr.net/gh/notlate-cn/imgs/blogs/c94b7122f71d8b7845ffca3fd239e314.jpg" alt="DRN在线学习过程图" style="zoom:33%;" />

主要包括三步：

* 第一步：对于已经训练好的当前网络 Q，对其模型参数 W 添加一个较小的随机扰动，得到一个新的模型参数，这里我们称对应的网络为探索网络 Q~，产生随机扰动公式如下：

  $ΔW=α·rand(-1, 1) · W$

  $α$ 是一个探索因子，决定探索力度的大小。$rand(-1,1)$产生的是一个$[-1,1]$之间的随机数。

* 第二步：对于当前网络 Q 和探索网络 $\tilde{Q}$，分别生成推荐列表 L 和 L~，再将两个推荐列表用间隔穿插（Interleaving）的方式融合，组合成一个推荐列表后推送给用户。

* 最后一步是实时收集用户反馈。如果探索网络 Q～生成内容的效果好于当前网络 Q，我们就用探索网络代替当前网络，进入下一轮迭代。反之，我们就保留当前网络。

#### （5）DRN的改进

最大的改进就是把模型推断、模型更新、推荐系统工程整个一体化了，让整个模型学习的过程变得更高效，能根据用户的实时奖励学到新知识，做出最实时的反馈。

但同时，也正是因为工程和模型紧紧地耦合在一起，让强化学习在推荐系统中的落地并不容易。

#### （6）问答经典

**① 竞争梯度下降算法的弊端是什么？**

每个参数的更新方向是随机的，而不是像随机下降算法一样，是沿着梯度更新的。随机更新可能导致的结果就是：1.收敛是缓慢的。2.很难收敛到全局最优值。

**② 如何判断竞争网络效果?**

在实际实现中**做一小段实践的数据收集**，再根据这个batch的效果进行探索网络和当前网络的选择。这部分在实际的工程中一般是在flink等流计算平台上实现的。

**③ 历史数据重新训练指的是从零训练吗？使用竞争梯度下降算法吗？**

主更新不使用竞争梯度下降算法。实际工程中可视为一次正常的模型更新，使用的是全量历史样本，当然这其中包括了最近收集到的样本。

**④ 增加实时性上采用FTRL进行在线学习和强化学习在最终结果上有什么区别，如何判断选择？**

online learning其实可以看作强化学习的一个子集，或者说是子类。所以FTRL做在线学习本质上就是强化学习的一种。



### 参考资料

《深度学习推荐系统实战》 -- 极客时间，王喆